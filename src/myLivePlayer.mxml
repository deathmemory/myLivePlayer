<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   xmlns:jw="com.longtailvideo.jwplayer.player.*"
			   xmlns:mk="org.lala.components.*"
			   applicationComplete="application1_applicationCompleteHandler(event)"
			   currentStateChange="application1_currentStateChangeHandler(event)"
			   addedToStage="application1_addedToStageHandler(event)"
			   width="100%" height="100%">
	
	<s:states>
		<s:State name="normal"/>
		<s:State name="fullScreen"/>
		<s:State name="wideScreen"/>
	</s:states>

	<fx:Style source="myLivePlayer.css" />
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
		<fx:String id='version'>2.1.0.30</fx:String>
		
		<s:Fade id="fadeOut" duration="3000" alphaFrom="1" alphaTo="0" />
		<s:Fade id="fadeIn" duration="1000" alphaFrom="0" alphaTo="1" />
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import org.lala.utils.PlayerTool;
			
			import com.longtailvideo.jwplayer.player.Player;
			
			import flashx.textLayout.conversion.TextConverter;
			import flashx.textLayout.elements.TextFlow;
			
			import mx.events.FlexEvent;
			import mx.events.StateChangeEvent;
			
			import org.lala.lang.langmgr;
			import org.lala.plugins.CommentView;
			import org.lala.utils.AppConfig;
			
			/** 主播放器 **/
			private var _player:Player;
			/** 应用程序配置 **/
			private var appConfig:AppConfig;
			private var savedState:String = 'normal';
			private var isInnerFullScreenState:Boolean = false;

			[Bindable]
			/** 弹幕播放器插件类的引用 **/
			private var commentView:CommentView = CommentView.getInstance();
			/** 播放器小助手 **/
			private var playerTool:PlayerTool;
			
			protected function onLoaderComplete(evt:Event):void
			{
				trace("onLoaderComplete");
			}
			
			protected function onLoaderIOError(evt:Event):void
			{
				trace("onLoaderIOError");
			}
			
			protected function onLoaderSecurityError(evt:Event):void
			{
				trace("onLoaderSecurityError");
			}
			
			private function playerReadyHandler(event:Event):void
			{
				trace('播放器初始化完成.');
				
				_player = livePlayer.player;
				playerTool = new PlayerTool(_player);
				loadVideo();
			}			
			
			protected function loadVideo():void
			{
				var flashVars:Object = this.systemManager.loaderInfo.parameters;
				if ( flashVars['vid'] )
				{
					playerTool.loadYoutubeVideo(flashVars.vid);
				}	
			}
			
			protected function application1_currentStateChangeHandler(event:StateChangeEvent):void
			{
				if ( appConfig )
					appConfig.state = this.currentState;
			}
			/** 在loadInfo可读取时立即初始化配置 **/
			protected function application1_addedToStageHandler(event:Event):void
			{
				var params:Object = loaderInfo.parameters;
				appConfig = new AppConfig(params);
				
				/** 初始化到无界面状态 **/
				if(appConfig.state == 'fullScreen')
				{
					//isInnerFullScreenState = true;
				}
			}
			
			protected function application1_applicationCompleteHandler(event:FlexEvent):void
			{
				Security.allowInsecureDomain("*");
				Security.allowDomain("*");
				/** 初始语言配置  **/
				this.initControlsLanguageCfg();
				this.currentState = appConfig.state;
				//commentView.addEventListener("innerFullScreen",innerFullScreenHandler);
				commentView.addEventListener("innerFullScreen",innerFullScreenHandler);
				commentView.version = NKSPLAYER::version;

				/** 全屏情况处理,更改state **/
				stage.addEventListener( FullScreenEvent.FULL_SCREEN, fullScreenHandler );
			}
			
			/** 初始化语言配置  **/
			private function initControlsLanguageCfg():void
			{
				langmgr.init(systemManager.loaderInfo.parameters);
			}
			
			/** 处理播放器的工具条上的隐藏弹幕界面按钮事件 **/
			private function innerFullScreenHandler(event:Event):void
			{
				if(stage.displayState == 'fullScreen')
				{
					return;
				}
				if(!isInnerFullScreenState)
				{
					savedState = currentState;
					currentState = 'fullScreen';
				}
				else
				{
					currentState = savedState;
				}
				isInnerFullScreenState = !isInnerFullScreenState;
			}
			/** 
			 * 全屏处理:fullScreen状态是播放器填满整个flash插件,全屏则是flash插件填满屏幕
			 * 其实是两个不同的状态,但是共用一个state,而使用isInnerFullScreenState来区分
			 ***/
			private function fullScreenHandler(event:FullScreenEvent):void
			{
				if(isInnerFullScreenState)
				{
					return;
				}
				if(stage.displayState == 'fullScreen')
				{
					savedState = currentState;
					currentState = 'fullScreen';
				}
				else
				{
					currentState = savedState;
				}
			}
		]]>
	</fx:Script>
	<s:Group width="100%" height="100%">
		<s:layout>
			<s:HorizontalLayout />
		</s:layout>
		<s:Group width="100%" height="100%">
			<s:layout>
				<s:VerticalLayout gap="1" paddingTop="0" paddingBottom="0"/>
			</s:layout>
			<s:BorderContainer borderWeight="0" width="100%" height="100%" backgroundColor="#000000" borderVisible="false">
				<jw:JWPlayer id="livePlayer" width="100%" height="100%" playerReady="playerReadyHandler(event)" 
							 top="0" bottom="0" left="0" right="0"/>
			</s:BorderContainer>
			<!-- 暂时去掉弹幕发送窗口 
			<s:BorderContainer width="100%" height="40" borderVisible="true" excludeFrom="fullScreen">
				<mk:NormalCommentInput id="nCommnetInput" width="100%" height="100%" />				
			</s:BorderContainer>
			-->
		</s:Group>
	</s:Group>
	
</s:Application>
